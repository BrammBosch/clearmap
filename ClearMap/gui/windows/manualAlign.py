import json
import tkinter as tk
from ClearMap.gui.tools.findLandmarks import findLandmarks
from ClearMap.gui.tools.killProgram import kill


def manual(root,pathClearMap):
    """
    If the user has selected to use the manual alignment using imageJ a popup window is opened where the user is asked
    to select an landmarks.csv file generated by imageJ's bigdataviewer plugin. It also shows the steps necessary to
    obtain these landmarks and how to export them.
    :return:
    """
    manualWindow = tk.Toplevel(root)
    manualWindow.title("Clearmap")

    tk.Label(manualWindow, text="""Open the "autofluo_resampled.tif file and the template file in ImageJ. 
Go to Plugins -> Big Data Viewer -> Bigwarp. Open the template first, then autofluo_resampled. 
In both images, hit Shift + A to flip both to coronal view. 
Scroll around and match the files as closely as possible 
(left click + pull around to tilt your plane of view in 3d. Ctrl + Y to reset to starter view.)
Landmark procedure: 
    click on one of the windows to make sure you are active in the right window. 
    Press Space bar to activate the landmark mode. 
    Click on one of the landmarks. 
    click the other window, re-activate landmark mode by pressing space bar(twice, if need be)
    Mark the same landmark. 
    Repeat until approx. 50-100 landmarks are marked. 
Go to the landmarks window -> File -> Export landmarks. """).grid(padx=4, pady=4, sticky='ew')
    findLandmarksButton = tk.Button(manualWindow, text="Search for the landmarks file",
                                    command=lambda: [findLandmarks(manualWindow, pathClearMap), manualWindow.destroy()])
    findLandmarksButton.grid(padx=4, pady=4, sticky='ew')

    def manual_quit():
        """
        If the window is closed this function is called which sets the kill parameter to True which stops the pipeline
        b√©fore it can run.
        :return:
        """
        kill(pathClearMap)

        manualWindow.destroy()

    manualWindow.protocol("WM_DELETE_WINDOW", manual_quit)

    manualWindow.wait_window(manualWindow)
